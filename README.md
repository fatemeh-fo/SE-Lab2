به نام خدا

# آشنایی با اصول شئ‌گرایی (موسوم به اصول SOLID)

## بخش دوم: دستور آزمایش

### گام ۱: افزودن یک روش پیام رسانی دیگر

	تغییراتی را که در کد فعلی برنامه می‌دهید، در جدول زیر ثبت کنید و در نهایت تعداد کل تغییرات را اعلان کنید.
    - توجه: مواردی که به عنوان تغییرات باید اعلان شود شامل این موارد هستند:
      1. ساخت کلاس جدید
      2. افزودن تابع جدید به کلاس و یا واسط (برای توابع جدید صرفا اعلام تغییر کنید)
      3. هر خطوط پیاپی‌ای که در تابع main و برای افزودن یک قابلیت جدید اضافه می‌کنید. به عنوان مثال اگر سه خط را به منظور تشخیص نوع پیام اضافه می‌کنید، آن سه خط را در قالب یک تغییر اعلام کنید (البته جزییات آن را در ستون «شرحی کوتاه از تغییر» توضیح دهید).

| شرحی کوتاه از تغییر | عنوان تغییر |‌ محل اعمال تغییرات (کلاس/واسط) | ردیف|
|--:|--:|:--:|:--:|
| ساخت یک کلاس public که از MessageService ارث میبرد | ساخت کلاس سرویس مسج‌دهی تلگرام| TelegramMessageService| ۱ |
| اضافه کردن تابع sendSmsMessage در TelegramMessageService با بدنه خالی | افزودن تابع با بدنه خالی sendSmsMessage به TelegramMessageService | TelegramMessageService| ۲ |
| اضافه کردن تابع sendEmailMessage در TelegramMessageService با بدنه خالی | افزودن تابع با بدنه خالی sendEmailMessage به TelegramMessageService | TelegramMessageService| ۳ |
| اضافه کردن کلاس public به نام TelegramMessage که از Message ارث  میبرد و دارای دو field به نامهای sourceId و targetId هست. | ساخت کلاس TelegramMessage | TelegramMessage | ۴ |
| افزودن تابع void sendTelegramMessage(TelegramMessage message) به MessageService | افزودن تابع sendTelegramMessage به واسط MessageService | MessageService | ۵ |
| اضافه کردن تابع sendTelegramMessage در EmailMessageSevice با بدنه خالی | پیاده‌‌سازی تابع sendTelegramMessage با بدنه‌ی خالی | EmailMessageSevice | ۶ |
| اضافه کردن تابع sendTelegramMessage در SmsMessageSevice با بدنه خالی | پیاده‌‌سازی تابع sendTelegramMessage با بدنه‌ی خالی | SmsMessageSevice | ۷ |
| بررسی شروع شدن sourceId و targetId با حرف '@' و درصورت قبولی، پرینت کردن جمله‌ی حاوی پیام تایید ارسال | پیاده‌سازی تابع sendTelegramMessage در TelegramMessageService | TelegramMessageSevice | ۸ |
| دریافت آیدی مبدا و مقصد و محتویات پیغام تلگرامی و اجرای کلاس TelegramMessageService | افزودن امکان ارسال پیام تلگرامی | Main | ۹ |

مجموع تعداد تغییرات: ۹

### گام ۲: تحلیل و وارسی برنامه از منظر تحقق و یا عدم تحقق اصول SOLID
در خصوص این برنامه‌ای که نوشته شده بود و شما یک قابلیت به آن اضافه کردید، بر اساس اصول SOLID موارد نقض و یا محقق شدن هر کدام از آن اصول را بیان کنید. در بیان موارد تحقق و نقض، علت تحقق و یا نقض را نیز به صورت کامل توضیح دهید:

| موارد  نقض |‌ موارد تحقق | نام اصل SOLID |‌ ردیف |
|--:|--:|:--:|:--:|
| کلاس Main مسئولیت‌های متعددی دارد: دریافت ورودی، ایجاد پیام‌ها، و مدیریت سرویس‌های ارسال | کلاس‌های Message و زیرکلاس‌های آن هر کدام مسئولیت مشخص و واحدی دارند | Single Responsibility Principle (SRP) | 1 |
| برای افزودن هر نوع پیام جدید باید کد Main را تغییر داد و switch-case جدید اضافه کرد | ساختار کلی Message و MessageService به گونه‌ای است که می‌توان انواع جدید پیام را با ارث‌بری اضافه کرد | Open-Close Principle (OCP) | 2 |
| سرویس‌های پیام‌رسان در توابعی که مربوط به سایر سرویس‌ها هستند بدنه خالی دارند که نقض LSP است | زیرکلاس‌های Message به درستی جایگزین کلاس پایه می‌شوند | Liskov Substitution Principle (LSP) | 3 |
| واسط MessageService شامل متدهایی است که برای همه پیاده‌سازی‌ها مورد نیاز نیست و بدنه خالی دارند | - | Interface Segregation Principle (ISP) | 4 |
| کلاس Main مستقیماً به پیاده‌سازی‌های خاص وابسته است | ساختار کلی برنامه از interface MessageService استفاده می‌کند | Dependency Inversion Principle (DIP) | 5 |

در خصوص هرکدام از موارد نقض هرکدام از اصول، یک راهکار را به منظور رفع آن مشکل ارایه داده و در جدول زیر ثبت نمایید:

| راه حل پیشنهادی | علت نقض | اصل مربوطه |
|--:|--:|:--:|
| جداسازی مسئولیت‌های کلاس Main به کلاس‌های جداگانه برای UI و مدیریت پیام‌ها | تجمع مسئولیت‌های مختلف در Main | SRP |
| استفاده از Factory Pattern برای ساخت پیام‌ها و حذف switch-case | نیاز به تغییر کد برای افزودن نوع جدید پیام | OCP |
| تعریف interface‌های جداگانه برای هر نوع سرویس پیام‌رسان | وجود متدهای غیرضروری با بدنه خالی در سرویس‌ها | ISP |
| استفاده از MessageFactory و ServiceFactory برای کاهش وابستگی مستقیم | وابستگی مستقیم به پیاده‌سازی‌ها در Main | DIP |


### گام ۳: اصلاح موارد نقض
در نهایت، بر اساس تحلیلی که انجام داده‌اید و راه حل‌هایی که در بخش قبل ارایه کردید، کد را اصلاح کرده و بر روی مخزن گیت‌هاب و در پوشه‌ای مجزا از گام قبل commit و push کنید. انتظار می‌رود که تمامی راه حل‌های پیشنهادی خود را بر روی این نسخه اعمال کنید و تمامی بهبودهایی که انجام می‌دهید، در جداول بخش قبل موجود باشد.

### گام ۴: بررسی مجدد تغییرات مورد نیاز
فرض کنید که گام 1 را برای کد اصلاح شده (پس از انجام گام‌های ۲ و ۳) اجرا کرده‌اید.

    1. در این صورت از انجام کدام یک از تغییرات ثبت شده در جدول گام ۱ معاف خواهید شد؟
      - تغییرات ۲ و ۳ و ۵ و ۶ و ۷ و ۹
    2. تعداد تغییرات مورد نیاز، چند تغییر خواهد شد؟
      - تغییرات لازم بترتیب زیر خواهند شد:
        ۱. افزودن MessageType جدید
        ۲. افزودن یک case جدید به MessageFactory
        ۳. افزودن یک case جدید به MessageServiceFactory
        ۴. افزودن یک کلاس model جدید
        ۵. افزودن یک interface جدید و پیاده‌سازی implementation آن
        ۶. افزودن یک منوی جدید در Main::MessengerUI::displayMenu
        ۷. افزودن یک case جدید به Main::MessengerUI::handleUserChoice
        ۸. افزودن یک case جدید به Main::MessengerUI::fillMessageDetails
        ۹. افزودن یک case جدید به Main::MessengerUI::sendMessage
      - در کل باز هم تعداد تغییرات ۹ تا خواهد بود ولی این تغییرات منسجم‌تر و مرتبط‌تر هستند، هر تغییر در جای منطقی خودش قرار دارد،‌ اصول SOLID بهتر رعایت شده‌اند، و کد خواناتر و نگهداری آن ساده‌تر است.

### گام ۵: جمع بندی
در این بخش، بیان کنید که از این گام چه نتیجه‌ای گرفته‌اید؟ و به نظر شما به کارگیری صحیح اصول SOLID در گام‌های ۳ و ۴ چه مزایایی را نسبت به حالتی دارد که این اصول رعایت نشده‌بود؟

**مزایای استفاده از اصول SOLID**
```
  1. جداسازی مسئولیت‌ها (SRP):
    - هر کلاس یک وظیفه مشخص دارد
    - سرویس‌های ارسال پیام از هم جدا شده‌اند
    - منطق validation در کلاس مربوط به خودش قرار گرفته
  2. قابلیت توسعه بهتر (OCP):
    - برای اضافه کردن پیام‌رسان جدید، نیاز به تغییر کد موجود نیست
    - فقط کلاس‌های جدید اضافه می‌شوند
    - تغییرات محدود به افزودن کد جدید است، نه تغییر کد قبلی
  3. انعطاف‌پذیری بیشتر (LSP & ISP):
    - هر سرویس پیام‌رسان interface خودش را دارد
    - امکان جایگزینی پیاده‌سازی‌ها بدون تغییر در بقیه کد
    - وابستگی‌های کمتر بین بخش‌های مختلف
  4. مدیریت وابستگی‌ها (DIP):
    - استفاده از Factory‌ها برای ایجاد اشیاء
    - وابستگی به abstraction به جای پیاده‌سازی مشخص
    - جداسازی بهتر لایه‌های مختلف برنامه
```

**مقایسه با حالت قبل**

| بعد | قبل | جنبه |
|--:|--:|:--:|
| کد ماژولار و سازمان‌یافته | کد درهم تنیده و پیچیده | ساختار کد |
| تغییرات ایزوله و کم‌ریسک | تغییرات پرریسک و زمان‌بر | نگهداری |
| اضافه کردن کلاس‌های جدید بدون تغییر کد موجود | نیاز به تغییر در چندین جای کد |‌ توسعه‌پذیری |
| تست هر بخش به صورت مجزا و ساده | تست کردن سخت به دلیل وابستگی‌های زیاد | تست‌پذیری |

**نتیجه‌گیری نهایی**

رعایت اصول SOLID اگرچه ممکن است در ابتدا باعث پیچیده‌تر شدن ساختار کد شود، اما در بلندمدت مزایای بسیاری دارد که مهمترین آنها کاهش هزینه نگهداری، افزایش قابلیت توسعه، کاهش ریسک تغییرات، بهبود خوانایی و قابلیت درک کد، و تست‌پذیری بهتر است.

## نحوه ارسال پروژه:
1.	گام ۱ را انجام داده و سپس کد نوشته شده‌ی خود را (با رعایت محدودیت‌های گفته شده در گام) در یک پوشه به نام Step_1_Non_SOLID ذخیره کنید و در مخزن گام ۲ قرار دهید. موارد توضیحی بایستی در بخش README مخزن قرار گیرد.
2.	گام ۲ (که بخش تحلیلی است) در فایل README مربوط به مخزن گام ۲ آورده شود (تمام جداول با فرمت داده شده و عناوین هرکدام از سوالات پرسیده شده بایستی در README آورده شود).
3.	گام ۳ که شامل بهبود است، بایستی به صورت جداگانه در پوشه دیگری به نام Step_3_With_SOLID قرار داده شود و در مخزن موجود باشد.
4.	گام ۴ نیز در قالب توضیحات در README مخزن آورده شود.
5.	گام ۵ (که نتیجه گیری است) در README مخزن آورده شود.
